package scala.scalanative
package native

import scala.reflect.ClassTag
import scalanative.runtime._
import scalanative.runtime.Intrinsics._

sealed abstract class Tag[T] {
  def size: Int
  def alignment: Int
  def load(ptr: native.Ptr[T]): T = throwUndefined()
  def store(ptr: native.Ptr[T], value: T): Unit = throwUndefined()
}

object Tag {
  final case class Ptr[T](of: Tag[T])
      extends Tag[native.Ptr[T]] {
    @inline final def size: Int = 8
    @inline final def alignment: Int = 8
    @inline final override def load(ptr: native.Ptr[native.Ptr[T]]): native.Ptr[T] =
      fromRawPtr[T](loadRawPtr(toRawPtr(ptr)))
    @inline final override def store(ptr: native.Ptr[native.Ptr[T]], value: native.Ptr[T]): Unit =
      storeRawPtr(toRawPtr(ptr), toRawPtr(value))
  }

  final case class Class[T <: AnyRef](of: java.lang.Class[T])
      extends Tag[T] {
    @inline final def size: Int = 8
    @inline final def alignment: Int = 8
    @inline final override def load(ptr: native.Ptr[T]): T =
      loadObject(toRawPtr(ptr)).asInstanceOf[T]
    @inline final override def store(ptr: native.Ptr[T], value: T): Unit =
      storeObject(toRawPtr(ptr), value.asInstanceOf[Object])
  }

  % prims = [('Unit', 'scala.Unit', 8),
  %          ('Boolean', 'scala.Boolean', 1),
  %          ('Char', 'scala.Char', 2),
  %          ('Byte', 'scala.Byte', 1),
  %          ('UByte', 'native.UByte', 1),
  %          ('Short', 'scala.Short', 2),
  %          ('UShort', 'native.UShort', 2),
  %          ('Int', 'scala.Int', 4),
  %          ('UInt', 'native.UInt', 4),
  %          ('Long', 'scala.Long', 8),
  %          ('ULong', 'native.ULong', 8),
  %          ('Float', 'scala.Float', 4),
  %          ('Double', 'scala.Double', 8)]
  % for (name, T, size) in prims:

  object ${name} extends Tag[${T}] {
    @inline final def size: Int = ${size}
    @inline final def alignment: Int = ${size}
    @inline final override def load(ptr: native.Ptr[${T}]): ${T} =
      % if name == 'Unit':
      loadObject(toRawPtr(ptr)).asInstanceOf[Unit]
      % elif name.startswith('U'):
      %   signed = name[1:]
      load${signed}(toRawPtr(ptr)).to${name}
      % else:
      load${name}(toRawPtr(ptr))
      % end
    @inline final override def store(ptr: native.Ptr[${T}], value: ${T}): Unit =
      % if name == 'Unit':
      storeObject(toRawPtr(ptr), value.asInstanceOf[Object])
      % elif name.startswith('U'):
      %   signed = name[1:]
      store${signed}(toRawPtr(ptr), value.to${signed})
      % else:
      store${name}(toRawPtr(ptr), value)
      % end
  }

  % end

  % for N in range(0, 10):

  object Nat${N} extends Tag[native.Nat._${N}] {
    @noinline final def size: Int = throwUndefined()
    @noinline final def alignment: Int = throwUndefined()
  }

  % end

  % for N in range(1, 23):

  sealed trait Field${N}[T, F] extends Tag[T] {
    def _${N}: Tag[F]
    def offset${N}: Int
  }

  % end

  final case class Digit[N <: native.Nat.Base, M <: native.Nat](n: Tag[N], m: Tag[M])
      extends Tag[native.Nat.Digit[N, M]]
  {
    @inline final def size: Int = throwUndefined()
    @inline final def alignment: Int = throwUndefined()
  }

  final case class CArray[T, N <: native.Nat](of: Tag[T], n: Tag[N])
      extends Tag[native.CArray[T, N]]
  % for N in range(1, 23):
      with Field${N}[native.CArray[T, N], T]
  % end
  {
    final def size: Int = {
      var mul = 1
      def natToInt(tag: Tag[_]): Int = tag match {
        % for N in range(0, 10):
        case Tag.Nat${N} => ${N}
        % end
        case Tag.Digit(n, m) =>
          val mint = natToInt(m)
          mul *= 10
          natToInt(n) * mul + mint
        case _ =>
          throwUndefined()
      }
      of.size * natToInt(n)
    }
    @inline final def alignment: Int =
      of.alignment
    override def load(ptr: native.Ptr[native.CArray[T, N]]): native.CArray[T, N] = {
      new native.CArray[T, N](toRawPtr(ptr))
    }
    override def store(ptr: native.Ptr[native.CArray[T, N]], value: native.CArray[T, N]): Unit = {
      val dst = toRawPtr(ptr)
      val src = value.rawptr
      libc.memcpy(dst, src, size)
    }
    % for N in range(1, 23):
    def _${N}: Tag[T] = of
    def offset${N}: Int = of.size * ${N - 1}
    % end
  }

  @inline private[scalanative] def align(offset: Int, alignment: Int) = {
    val alignmentMask = alignment - 1
    val padding =
      if ((offset & alignmentMask) == 0) 0
      else alignment - (offset & alignmentMask)
    offset + padding
  }

  % for N in range(0, 23):
  %   Ts      = ["T" + str(i) for i in range(1, N + 1)]
  %   JustTs  = "" if N == 0 else "[" + ", ".join(Ts) + "]"
  %   TagTs   = ["Tag[{}]".format(T) for T in Ts]
  %   args    = ", ".join("_{}: {}".format(i + 1, T) for (i, T) in enumerate(TagTs))
  %   CStruct = "CStruct{}{}".format(N, JustTs)

  final case class ${CStruct}(${args})
    extends Tag[native.${CStruct}]
  % for M in range(1, N + 1):
    with Field${M}[native.CStruct${N}${JustTs}, ${Ts[M - 1]}]
  % end
  {
    final def size: Int = {
      var res = 0
      % for i in range(1, N + 1):
      res = align(res, _${i}.alignment) + _${i}.size
      % end
      align(res, alignment)
    }
    final def alignment: Int = {
      var res = 1
      % for i in range(1, N + 1):
      res = res max _${i}.alignment
      % end
      res
    }
    override def load(ptr: native.Ptr[native.${CStruct}]): native.${CStruct} = {
      new native.${CStruct}(toRawPtr(ptr))
    }
    override def store(ptr: native.Ptr[native.${CStruct}], value: native.${CStruct}): Unit = {
      val dst = toRawPtr(ptr)
      val src = value.rawptr
      libc.memcpy(dst, src, size)
    }
    % for fld in range(1, N + 1):
    def offset${fld}: Int = {
      var res = 0
      % for i in range(1, fld):
      res = align(res, _${i}.alignment) + _${i}.size
      % end
      align(res, _${fld}.alignment)
    }
    % end
  }

  % end

  implicit def materializePtrTag[T](implicit tag: Tag[T]): Tag[native.Ptr[T]] =
    Tag.Ptr(tag)
  implicit def materializeClassTag[T <: AnyRef: ClassTag]: Tag[T] =
    Tag.Class(implicitly[ClassTag[T]].runtimeClass.asInstanceOf[java.lang.Class[T]])
  % for (name, T, _) in prims:
  implicit def materialize${name}Tag: Tag[${T}] =
    ${name}
  % end
  % for N in range(0, 10):
  implicit def materializeNat${N}Tag: Tag[native.Nat._${N}] =
    Nat${N}
  %end
  implicit def materializeNatDigitTag[N <: native.Nat.Base: Tag, M <: native.Nat: Tag]: Tag[native.Nat.Digit[N, M]] =
    Tag.Digit(implicitly[Tag[N]], implicitly[Tag[M]])
  implicit def materializeCArrayTag[T: Tag, N <: native.Nat: Tag]: Tag.CArray[T, N] =
    Tag.CArray(implicitly[Tag[T]], implicitly[Tag[N]])
  % for N in range(0, 23):
  %   Ts      = ["T" + str(i) for i in range(1, N + 1)]
  %   BoundTs = "" if N == 0 else "[" + ", ".join(map(lambda T: T + ": Tag", Ts)) + "]"
  %   JustTs  = "" if N == 0 else "[" + ", ".join(Ts) + "]"
  %   tags    = ", ".join("implicitly[Tag[{}]]".format(T) for T in Ts)
  implicit def materializeCStruct${N}Tag${BoundTs}: Tag.CStruct${N}${JustTs} =
    Tag.CStruct${N}(${tags})
  % end
}
