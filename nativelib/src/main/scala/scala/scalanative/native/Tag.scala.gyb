package scala.scalanative
package native

import scala.reflect.ClassTag
import scalanative.runtime.{intrinsic, throwUndefined}

sealed abstract class Tag[P] {
  def size: Int
  def alignment: Int
  def offset(idx: Int): Int = throwUndefined()
}

object Tag {
  implicit def materializePtrTag[T](implicit tag: Tag[T]): Tag[native.Ptr[T]] =
    Tag.Ptr(tag)
  implicit def materializeNatDigit[N <: Nat.Base: Tag, M <: Nat: Tag]: Tag[native.Nat.Digit[N, M]] =
    Tag.Digit(implicitly[Tag[N]], implicitly[Tag[M]])
  implicit def materializeCArray[T: Tag, N <: Nat: Tag]: Tag[native.CArray[T, N]] =
    Tag.CArray(implicitly[Tag[T]], implicitly[Tag[N]])
  implicit def materializeClassTag[T <: AnyRef: ClassTag]: Tag[T] =
    Tag.Class(implicitly[ClassTag[T]].runtimeClass.asInstanceOf[java.lang.Class[T]])

  % for N in range(0, 23):
  %   Ts      = ["T" + str(i) for i in range(1, N + 1)]
  %   BoundTs = "" if N == 0 else "[" + ", ".join(map(lambda T: T + ": Tag", Ts)) + "]"
  %   JustTs  = "" if N == 0 else "[" + ", ".join(Ts) + "]"
  %   tags    = ", ".join("implicitly[Tag[{}]]".format(T) for T in Ts)

  implicit def materializeCStruct${N}${BoundTs}: Tag[native.CStruct${N}${JustTs}] =
    Tag.CStruct${N}(${tags})

  % end

  private[scalanative] sealed trait CStruct

  final case class Ptr[T](of: Tag[T])
      extends Tag[native.Ptr[T]] {
    @inline final def size: Int = 8
    @inline final def alignment: Int = 8
  }

  final case class Class[T <: AnyRef](of: java.lang.Class[T])
      extends Tag[T] {
    @inline final def size: Int = 8
    @inline final def alignment: Int = 8
  }

  final case class Digit[N <: Nat.Base, M <: Nat](n: Tag[N], m: Tag[M])
      extends Tag[native.Nat.Digit[N, M]] {
    @inline final def size: Int = throwUndefined()
    @inline final def alignment: Int = throwUndefined()
  }

  final case class CArray[T, N <: Nat](of: Tag[T], n: Tag[N])
      extends Tag[native.CArray[T, N]] {
    final def size: Int = {
      def natToInt(tag: Tag[_]): Int = tag match {
        % for N in range(0, 10):
        case Nat${N} => ${N}
        % end
        case Digit(n, m) => natToInt(n) + natToInt(m) * 10
        case _           => throwUndefined()
      }
      of.size * natToInt(n)
    }
    @inline final def alignment: Int = of.alignment
    @inline override def offset(idx: Int): Int = of.size * idx
  }

  % for (name, T, size) in [('Unit', 'scala.Unit', 8),
  %                         ('Boolean', 'scala.Boolean', 1),
  %                         ('Char', 'scala.Char', 2),
  %                         ('Byte', 'scala.Byte', 1),
  %                         ('UByte', 'native.UByte', 1),
  %                         ('Short', 'scala.Short', 2),
  %                         ('UShort', 'native.UShort', 2),
  %                         ('Int', 'scala.Int', 4),
  %                         ('UInt', 'native.UInt', 4),
  %                         ('Long', 'scala.Long', 8),
  %                         ('ULong', 'native.ULong', 8),
  %                         ('Float', 'scala.Float', 4),
  %                         ('Double', 'scala.Double', 8)]:

  implicit object ${name} extends Tag[${T}] {
    @inline final def size: Int = ${size}
    @inline final def alignment: Int = ${size}
  }

  % end
  % for N in range(0, 10):

  implicit object Nat${N} extends Tag[native.Nat._${N}] {
    @noinline final def size: Int = throwUndefined()
    @noinline final def alignment: Int = throwUndefined()
  }

  % end

  @inline private[scalanative] def align(offset: Int, alignment: Int) = {
    val alignmentMask = alignment - 1
    val padding =
      if ((offset & alignmentMask) == 0) 0
      else alignment - (offset & alignmentMask)
    offset + padding
  }

  % for N in range(0, 23):
  %   Ts      = ["T" + str(i) for i in range(1, N + 1)]
  %   JustTs  = "" if N == 0 else "[" + ", ".join(Ts) + "]"
  %   TagTs   = ["Tag[{}]".format(T) for T in Ts]
  %   args    = ", ".join("_{}: {}".format(i + 1, T) for (i, T) in enumerate(TagTs))

  final case class CStruct${N}${JustTs}(${args}) extends Tag[native.CStruct${N}${JustTs}] with CStruct {
    final def size: Int = {
      var res = 0
      % for i in range(1, N + 1):
      res = align(res, _${i}.alignment) + _${i}.size
      % end
      align(res, alignment)
    }
    final def alignment: Int = {
      var res = 1
      % for i in range(1, N + 1):
      res = res max _${i}.alignment
      % end
      res
    }
    override def offset(idx: Int): Int = idx match {
      % for fld in range(1, N + 1):
      case ${fld} =>
        var res = 0
        % for i in range(1, fld):
        res = align(res, _${i}.alignment) + _${i}.size
        % end
        align(res, _${fld}.alignment)
      % end
      case _ =>
        throwUndefined()
    }
  }

  % end

 }
